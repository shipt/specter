'use strict';

/**
 * Config
 */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

L.mapbox.accessToken = mpapi;

var CHECK_VERSION_TIMEOUT_MS = 3000;
var RECONNECT_TIMEOUT_MS = 3000;
var STATUS_COLORS = {
  success: 'aqua',
  clientError: 'yellow',
  serverError: 'red'
};
var hqCircleLayer = new L.LayerGroup();
var circlesLayer = new L.LayerGroup();
var requestsPerSecCounter = 0;
var hqArray = [];
var circlesCanvas = L.canvas();
var ripplesEl = void 0;
var trafficSvg = void 0;

self.appVersion = '';
self.debug = false;

/**
 * React (i.e. Presentation Layer)
 */

var App = function (_React$PureComponent) {
  _inherits(App, _React$PureComponent);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.toggleErrorLogger = function () {
      var showErrorLogs = !_this.state.showErrorLogs;
      if (showErrorLogs === false) _this.setState({ errorLogs: [] });
      _this.setState({ showErrorLogs: showErrorLogs });
      // also turns on browser console logs
      self.debug = showErrorLogs;
    };

    _this.setErrorLog = function (log) {
      if (_this.state.showErrorLogs) {
        _this.setState(function (prevState) {
          return { errorLogs: [].concat(_toConsumableArray(prevState.errorLogs), [log]) };
        });
        logger(log);
      }
    };

    _this.state = {
      errorLogs: [],
      showErrorLogs: false,
      hasError: false,
      rpsCount: 0,
      appVersion: '',
      reconnectTimeoutMs: RECONNECT_TIMEOUT_MS
    };
    return _this;
  }

  _createClass(App, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // init #map
      this.map = L.mapbox.map('map', 'mapbox.dark', {
        center: [37.090240, -95.712891], // center on North America
        zoom: 6
      }).addLayer(hqCircleLayer).addLayer(circlesLayer);

      trafficSvg = d3.select(this.map.getPanes().overlayPane).append('svg').attr('class', 'leaflet-zoom-animated').attr('width', window.innerWidth).attr('height', window.innerHeight);

      ripplesEl = d3.select(this.map.getPanes().overlayPane).append('ripples').attr('width', window.innerWidth).attr('height', window.innerHeight).call(drawOnCanvas);

      // read app version
      // MUST happen before HEAD /version, which polls every so often
      fetch('/version', { method: 'HEAD' }).then(function (res) {
        self.version = res.headers.get('Version');
      });

      this.setupWebSocket();
    }
  }, {
    key: 'setupWebSocket',
    value: function setupWebSocket() {
      var _this2 = this;

      try {
        var uri = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        uri += '//' + window.location.host;
        uri += window.location.pathname + 'ws';
        this.ws = new WebSocket(uri);

        this.ws.onmessage = function (evt) {
          // exit early if we get bad JSON data
          if (evt.data === '') return;
          var wsData = JSON.parse(evt.data);
          var srcLatLng = new L.LatLng(wsData.SrcLat, wsData.SrcLong);
          var hqLatLng = new L.LatLng(wsData.DstLat, wsData.DstLong);
          requestsPerSecCounter++;
          // exit early if we get strange location data (i.e. from center of the earth to center of the earth)
          if (srcLatLng.lat === 0 && srcLatLng.lng === 0) {
            return;
          } else if (srcLatLng.lat === 39.833 && srcLatLng.lng === -98.585) {
            return;
          } else if (srcLatLng.lat === 37.751 && srcLatLng.lng === -97.822) {
            return;
          }

          var srcPoint = _this2.map.latLngToLayerPoint(srcLatLng);
          var hqPoint = _this2.map.latLngToLayerPoint(hqLatLng);
          var httpStatus = Number(wsData.HTTPStatus);
          var midPoint = calcMidpoint(srcPoint, hqPoint);
          var statusColor = getStatusColor(httpStatus);

          if (shouldUpdateHQ(hqLatLng)) {
            addHQCircle(hqLatLng);
            hqArray.push(hqLatLng);
          }
          addCircleWithColor(srcLatLng, statusColor);
          handleRippleWithColor(srcPoint, statusColor);
          handleTrafficWithColor(srcPoint, midPoint, hqPoint, statusColor);

          // log server errors to UI
          if (httpStatus >= 500) {
            _this2.setErrorLog(httpStatus + ' Error from ' + srcLatLng + ' to ' + hqLatLng);
          }
        };

        // event setup for things like rps counters, etc
        this.ws.onopen = function () {
          _this2.setErrorLog('WebSocket connected to ' + uri);
          _this2.setState({ hasError: false, reconnectTimeoutMs: RECONNECT_TIMEOUT_MS });
          // setup counter
          _this2.requestCounter = setInterval(function () {
            _this2.setState(function () {
              var rpsCount = requestsPerSecCounter;
              requestsPerSecCounter = 0;
              return { rpsCount: rpsCount };
            });
          }, 1000);

          // this doubles as a kind of heartbeat to see if we still have connection to WS
          _this2.pollVersion = setInterval(function () {
            return fetchVersionService(_this2.ws);
          }, CHECK_VERSION_TIMEOUT_MS);
        };

        // clear/cleanup active events
        this.ws.onclose = function () {
          _this2.setErrorLog('on close callback invoked');
          _this2.setState({ hasError: true });
          _this2.retryWebSocket();
        };

        this.ws.onerror = function () {
          _this2.setErrorLog('on error callback invoked');
          _this2.setState({ hasError: true });
        };
      } catch (e) {
        this.setState({ hasError: true });
        this.setErrorLog('caught error: ' + e.message);
        this.retryWebSocket();
      }
    }
  }, {
    key: 'retryWebSocket',
    value: function retryWebSocket() {
      var _this3 = this;

      requestsPerSecCounter = 0;
      this.setState({ rpsCount: 0 });
      this.setErrorLog('Websocket Terminated. Retrying in ' + this.state.reconnectTimeoutMs + '...');
      clearInterval(this.requestCounter);
      clearInterval(this.pollVersion);
      // retry connection
      setTimeout(function () {
        _this3.setupWebSocket();
        // incremental back-off
        _this3.setState(function (prevState) {
          return { reconnectTimeoutMs: prevState.reconnectTimeoutMs + 1000 };
        });
      }, this.state.reconnectTimeoutMs);
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          errorLogs = _state.errorLogs,
          showErrorLogs = _state.showErrorLogs,
          rpsCount = _state.rpsCount,
          appVersion = _state.appVersion,
          hasError = _state.hasError,
          reconnectTimeoutMs = _state.reconnectTimeoutMs;

      return [React.createElement('div', { key: 'map', id: 'map' }), React.createElement(LegendComponent, { key: 'legend', onClick: this.toggleErrorLogger, rpsCount: rpsCount, isDebugging: showErrorLogs, appVersion: appVersion }), React.createElement(ErrorLoggerComponent, { key: 'error-logger', logs: errorLogs, show: showErrorLogs }), React.createElement(ReconnectBannerComponent, { key: 'error-banner', show: hasError, reconnectTimeoutMs: reconnectTimeoutMs })];
    }
  }]);

  return App;
}(React.PureComponent);

var LegendComponent = React.memo(function (_ref) {
  var onClick = _ref.onClick,
      innerRef = _ref.innerRef,
      rpsCount = _ref.rpsCount,
      isDebugging = _ref.isDebugging,
      appVersion = _ref.appVersion;
  return React.createElement(
    'div',
    { id: 'legend', ref: innerRef },
    React.createElement(
      'div',
      { style: { float: 'right', color: '#888' } },
      appVersion
    ),
    React.createElement(
      'h2',
      null,
      'HTTP Traffic Status'
    ),
    React.createElement(
      'div',
      null,
      'Data Center: ',
      React.createElement(
        'span',
        { style: { color: 'white', fontWeight: 'bold' } },
        'white'
      )
    ),
    React.createElement(
      'div',
      null,
      '2xx Success: ',
      React.createElement(
        'span',
        { style: { color: STATUS_COLORS.success, fontWeight: 'bold' } },
        STATUS_COLORS.success
      )
    ),
    React.createElement(
      'div',
      null,
      '4xx Client Error: ',
      React.createElement(
        'span',
        { style: { color: STATUS_COLORS.clientError, fontWeight: 'bold' } },
        STATUS_COLORS.clientError
      )
    ),
    React.createElement(
      'div',
      null,
      '5xx Server Error: ',
      React.createElement(
        'span',
        { style: { color: STATUS_COLORS.serverError, fontWeight: 'bold' } },
        STATUS_COLORS.serverError
      )
    ),
    React.createElement(
      'div',
      { style: { float: 'right' } },
      'Requests Per Second: ',
      rpsCount
    ),
    React.createElement(
      'button',
      { onClick: onClick },
      isDebugging ? 'Disable' : 'Enable',
      ' Debug Mode'
    )
  );
});

var ErrorLoggerComponent = React.memo(function (_ref2) {
  var logs = _ref2.logs,
      show = _ref2.show;
  return React.createElement(
    'div',
    { id: 'error-logger', style: show ? { display: 'block' } : { display: 'none' } },
    logs.map(function (msg, i) {
      return React.createElement(
        'div',
        { key: i },
        msg
      );
    })
  );
});

var ReconnectBannerComponent = React.memo(function (_ref3) {
  var show = _ref3.show,
      reconnectTimeoutMs = _ref3.reconnectTimeoutMs;

  if (!show) return null;

  var _React$useState = React.useState(reconnectTimeoutMs / 1000),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      seconds = _React$useState2[0],
      setSeconds = _React$useState2[1];

  React.useEffect(function () {
    var countDown = setInterval(function () {
      setSeconds(function (prevSec) {
        return prevSec - 1;
      });
    }, 1000);
    return function cleanup() {
      setSeconds(reconnectTimeoutMs / 1000);
      clearInterval(countDown);
    };
  }, [reconnectTimeoutMs]);

  return React.createElement(
    'div',
    { id: 'error-banner' },
    seconds < 0 ? 'Unable to reconnect. Check your network connection.' : 'Experiencing network issues. Attempting to reconnect in ' + seconds + '...'
  );
});

// render app!
ReactDOM.render(React.createElement(App), document.getElementById('app'));

/**
 * Helper Functions
 * L.circle - https://leafletjs.com/reference-1.4.0.html#circle
 */
function addHQCircle(hqLatLng) {
  L.circle(hqLatLng, {
    renderer: circlesCanvas,
    radius: 50000,
    color: 'white',
    fillColor: 'white',
    fillOpacity: 0.8
  }).addTo(hqCircleLayer);

  logger('added HQ location', hqLatLng);
}

function addCircleWithColor(srcLatLng, color) {
  var circleArray = circlesLayer.getLayers();

  // Only allow 10 circles to be on the map at a time
  if (circleArray.length >= 10) {
    circlesLayer.removeLayer(circleArray[0]);
  }

  L.circle(srcLatLng, {
    renderer: circlesCanvas,
    radius: 50000,
    color: color,
    fillColor: color,
    fillOpacity: 0.2
  }).addTo(circlesLayer);
}

function handleRippleWithColor(srcPoint, color) {
  var x = srcPoint['x'];
  var y = srcPoint['y'];

  ripplesEl.append('ripple').attr('x', x).attr('y', y).attr('r', 1e-6).attr('stroke', color).attr('opacity', 1).transition().duration(2000).ease(Math.sqrt).attr('r', 35).attr('opacity', 1e-6).remove();
}

function handleTrafficWithColor(srcPoint, midPoint, hqPoint, color) {
  var lineData = [srcPoint, midPoint, hqPoint];
  var lineFunction = d3.svg.line().interpolate("basis").x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  });

  var lineGraph = trafficSvg.append('path').attr('d', lineFunction(lineData)).attr('stroke-opacity', 0.8).attr('stroke', color).attr('stroke-width', 2).attr('fill', 'none');

  var length = lineGraph.node().getTotalLength();

  lineGraph.attr('stroke-dasharray', length + ' ' + length).attr('stroke-dashoffset', length).transition().duration(70).ease('ease-in').attr('stroke-dashoffset', 0).each('end', function () {
    d3.select(this).transition().duration(100).style('stroke-opacity', 0).remove();
  });
}

function getStatusColor(httpStatus) {
  if (httpStatus >= 400 && httpStatus < 500) {
    return STATUS_COLORS.clientError;
  } else if (httpStatus >= 500) {
    return STATUS_COLORS.serverError;
  }
  return STATUS_COLORS.success;
}

function calcMidpoint(srcPoint, hqPoint) {
  var x1 = srcPoint['x'];
  var y1 = srcPoint['y'];
  var x2 = hqPoint['x'];
  var y2 = hqPoint['y'];
  var bendArray = [true, false];
  var bend = bendArray[Math.floor(Math.random() * bendArray.length)];

  if (y2 < y1 && x2 < x1) {
    var tmpy = y2;
    var tmpx = x2;
    x2 = x1;
    y2 = y1;
    x1 = tmpx;
    y1 = tmpy;
  } else if (y2 < y1) {
    var tmpy = y2;
    y2 = y1;
    y1 = tmpy;
  } else if (x2 < x1) {
    var tmpx = x2;
    x2 = x1;
    x1 = tmpx;
  }

  a = x2 + (x1 - x2);
  b = y2 + (y1 - y2);
  var radian = Math.atan(-((y2 - y1) / (x2 - x1)));
  var r = Math.sqrt(x2 - x1) + Math.sqrt(y2 - y1);
  var m1 = (x1 + x2) / 2;
  var m2 = (y1 + y2) / 2;

  var min = 2.5,
      max = 7.5;
  //var min = 1, max = 7;
  var arcIntensity = parseFloat((Math.random() * (max - min) + min).toFixed(2));

  if (bend === true) {
    var a = Math.floor(m1 - r * arcIntensity * Math.sin(radian));
    var b = Math.floor(m2 - r * arcIntensity * Math.cos(radian));
  } else {
    var a = Math.floor(m1 + r * arcIntensity * Math.sin(radian));
    var b = Math.floor(m2 + r * arcIntensity * Math.cos(radian));
  }

  return { "x": a, "y": b };
}

function shouldUpdateHQ(hqLatLng) {
  if (hqArray.some(function (loc) {
    return hqLatLng.lat === loc.lat && hqLatLng.lng === loc.lng;
  })) {
    // We already marked a dot for this hq so we dont need to again
    return false;
  } else {
    return true;
  }
}

function logger(msg1) {
  var msg2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (self.debug) console.log(msg1, msg2);
}

function drawOnCanvas(selection) {
  selection.each(function () {
    var root = this,
        canvas = root.parentNode.appendChild(document.createElement('canvas')),
        ctx = canvas.getContext('2d');

    canvas.style.position = 'absolute';

    // It'd be nice to use DOM Mutation Events here instead.
    // However, they appear to arrive irregularly, causing choppy animation.
    d3.timer(redraw);

    // Clear the canvas and then iterate over child elements.
    function redraw() {
      canvas.width = root.getAttribute('width');
      canvas.height = root.getAttribute('height');
      for (var child = root.firstChild; child; child = child.nextSibling) {
        draw(child);
      }
    }

    // For now we only support a circle's ripple effect with strokeStyle.
    // But imagine extending this to arbitrary shapes and groups!
    function draw(element) {
      switch (element.tagName) {
        case 'RIPPLE':
          {
            ctx.globalAlpha = element.getAttribute('opacity');
            ctx.strokeStyle = element.getAttribute('stroke');
            ctx.beginPath();
            ctx.arc(element.getAttribute('x'), element.getAttribute('y'), element.getAttribute('r'), 0, 2 * Math.PI);
            ctx.stroke();
            break;
          }
      }
    }
  });
};

// // uses fetch with a timeout (if connection is lost)
// function fetchVersionService(webSocket) {
//   let didTimeOut = false;
//   new Promise((resolve, reject) => {
//     const timeout = setTimeout(() => {
//       didTimeOut = true;
//       reject(new Error('Request timed out'));
//     }, CHECK_VERSION_TIMEOUT_MS);

//     fetch('/version', { method: 'HEAD' })
//       .then(res => {
//         // Clear the timeout as cleanup
//         clearTimeout(timeout);
//         if (didTimeOut) return;
//         if (!res.ok) reject(new Error('Failed to connect'))
//         // Auto-Refresh on update!
//         // https://developer.mozilla.org/en-US/docs/Web/API/Location/reload
//         const version = res.headers.get('Version')
//         if (self.appVersion !== version) {
//           location.reload(true);
//         }
//         resolve(res);
//       })
//       .catch(err => {
//         // Rejection already happened with setTimeout
//         if (didTimeOut) return;
//         // Reject with error
//         reject(err);
//       });
//   })
//     .catch(err => {
//       // since this uses the same service as WS, if this is down, then we've lost connection
//       // so we should close the WS connection
//       webSocket.close();
//       logger(`fetchVersionService::${err.message}`)
//     });
// }
